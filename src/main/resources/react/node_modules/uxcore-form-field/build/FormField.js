'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _uxcoreConst = require('uxcore-const');

var _uxcoreConst2 = _interopRequireDefault(_uxcoreConst);

var _classnames2 = require('classnames');

var _classnames3 = _interopRequireDefault(_classnames2);

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _isEqual = require('lodash/isEqual');

var _isEqual2 = _interopRequireDefault(_isEqual);

var _cloneDeep = require('lodash/cloneDeep');

var _cloneDeep2 = _interopRequireDefault(_cloneDeep);

var _lie = require('lie');

var _lie2 = _interopRequireDefault(_lie);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable class-methods-use-this */
var FormField = function (_React$Component) {
  _inherits(FormField, _React$Component);

  function FormField(props) {
    _classCallCheck(this, FormField);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.state = {
      value: props.value,
      formatValue: _this.formatValue(props.value),
      error: false,
      errMsg: ''
    };
    return _this;
  }

  FormField.prototype.componentDidMount = function componentDidMount() {
    var me = this;
    if (!me.props.standalone) {
      me.props.attachFormField(me);
      me.props.handleDataChange(me, {
        value: me.props.value,
        pass: true
      }, true);
    }
  };

  FormField.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var me = this;
    if (!(0, _isEqual2["default"])(nextProps.value, me.props.value)) {
      me.handleDataChange(nextProps.value, true, true, true);
    }
  };

  FormField.prototype.componentWillUnmount = function componentWillUnmount() {
    var me = this;
    if (!me.props.standalone) {
      this.props.detachFormField(this);
    }
  };

  FormField.prototype.getGridLayoutPercent = function getGridLayoutPercent(index) {
    var me = this;
    var gridLayout = me.props.gridLayout || me.props.jsxGridLayout;
    var newGrid = [gridLayout[0] || 6, gridLayout[1] || 12];
    return newGrid[index] * 100 / (24 - (index === 1 ? newGrid[0] : 0)) + '%';
  };

  FormField.prototype.getSize = function getSize() {
    var me = this;
    return me.props.size || me.props.jsxsize;
  };

  FormField.prototype.getProps = function getProps() {
    return this.props;
  };

  FormField.prototype.getLabelContentNode = function getLabelContentNode() {
    return this.labelContent;
  };

  FormField.prototype.getLabelNode = function getLabelNode() {
    return this.label;
  };

  FormField.prototype.getTipsNode = function getTipsNode() {
    return this.tips;
  };

  FormField.prototype.getRequiredNode = function getRequiredNode() {
    return this.required;
  };

  FormField.prototype.getErrorNode = function getErrorNode() {
    return this.errorNode;
  };

  FormField.prototype.getFieldCore = function getFieldCore() {
    return this.fieldCore;
  };

  FormField.prototype.getName = function getName() {
    return this.props.jsxname;
  };

  FormField.prototype.getValue = function getValue() {
    return this.formatValue(this.state.value);
  };

  FormField.prototype.setValue = function setValue(value, fromReset, fromPropsChange, next) {
    var me = this;
    var newState = {
      value: value,
      formatValue: me.formatValue(value),
      /*
       * why set state fromReset? some field like editor cannot be reset in the common way
       * so set this state to tell the field that you need to reset by yourself.
       */
      fromReset: !!fromReset
    };
    if (fromReset && fromPropsChange === undefined) {
      newState.error = false;
    }
    me.setState(newState, function () {
      if (next && typeof next === 'function') {
        next();
      }
    });
  };

  FormField.prototype.getDataProps = function getDataProps() {
    var _this2 = this;

    var dataProps = {};
    Object.keys(this.props).forEach(function (propName) {
      if (/^data-/.test(propName)) {
        dataProps[propName] = _this2.props[propName];
      }
    });
    return dataProps;
  };

  FormField.prototype.getDom = function getDom() {
    return this.fieldRoot;
  };

  /**
   * selectFormField depends on this method
   */
  // _isEqual(a, b) {
  //   return deepequal(a, b);
  // }

  /*
   * Fired when field value changes，update form's state and then trigger re-render.
   * @param fromReset {boolean} if handleDataChange is invoked by form's resetValues,
   */

  FormField.prototype.handleDataChange = function handleDataChange(value, fromReset, silence, fromPropsChange) {
    var me = this;
    var _me$props = me.props,
        asyncValidate = _me$props.asyncValidate,
        processValue = _me$props.processValue;

    var newValue = typeof processValue === 'function' ? processValue((0, _cloneDeep2["default"])(value)) : value;
    me.setValue(newValue, fromReset, fromPropsChange, function () {
      var pass = true;
      // validateOnBlur only support InputFormField & TextAraeFormField now
      if (!fromReset && !me.props.standalone && !me.props.validateOnBlur) {
        var validatePass = me.doValidate();
        if (!asyncValidate) {
          pass = validatePass;
        }
      }
      if (me.props.handleDataChange) {
        me.props.handleDataChange(me, {
          value: newValue,
          pass: pass
        }, silence);
      }
    });
  };

  /**
   * @return {boolean} if validate pass, return true, or, return false
   * if no rule, it means validate pass.
   */

  FormField.prototype.doValidate = function doValidate(force, always) {
    var me = this;
    var async = me.props.asyncValidate || false;
    var instant = true;
    if ('instantValidate' in me.props) {
      instant = me.props.instantValidate;
    } else {
      instant = me.props.jsxinstant;
    }
    // `force` has the top priority, `undefined` is not equal to `false`
    // `instant` has the sceond priority here
    // eternalsky@2016.03.15
    if (force === true || force !== false && instant) {
      if (me.props.jsxrules) {
        if (!async) {
          var error = me.isDirty(always);
          me.setState({
            error: error.isDirty,
            errMsg: error.errMsg
          });
          return !error.isDirty;
        }
        return new _lie2["default"](function (resolve) {
          me.isDirty(always, async).then(function (errMsg) {
            if (typeof errMsg === 'string') {
              me.setState({
                error: true,
                errMsg: errMsg
              });
              resolve(false);
            }
          })["catch"](function (err) {
            if ((typeof err === 'undefined' ? 'undefined' : _typeof(err)) === 'object' && err.stack) {
              console.error(err.stack);
            } else {
              me.setState({
                error: false
              });
              resolve(true);
            }
          });
        });
      }
      return true;
    }
    return true;
  };

  /*
   * rule can be an object, containing errMsg & validator,
   * and rule can also be an array containing such objects.
   * this func will check them one by one, and return false
   * unless all rules pass
   */

  FormField.prototype.isDirty = function isDirty(always) {
    var async = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var me = this;
    var rules = me.props.jsxrules;
    var isDirty = false;
    var errMsg = '';
    if (!async) {
      if ((typeof rules === 'undefined' ? 'undefined' : _typeof(rules)) === 'object' && !Array.isArray(rules)) {
        isDirty = always === undefined ? !rules.validator(me.state.value) : !always;
        errMsg = rules.errMsg;
      } else if (Array.isArray(rules)) {
        for (var i = 0; i < rules.length; i++) {
          isDirty = always === undefined ? !rules[i].validator(me.state.value) : !always;
          if (isDirty) {
            errMsg = rules[i].errMsg;
            break;
          }
        }
      }
      return {
        isDirty: isDirty,
        errMsg: errMsg
      };
    }
    if (typeof rules !== 'function') {
      console.error('Form Validate: In async validation mode,' + ' jsxrules(rules) should be a function');
      return {
        isDirty: false
      };
    }
    return new _lie2["default"](function (resolve, reject) {
      rules(me.state.value, reject, resolve);
    });
  };

  FormField.prototype.isMessageError = function isMessageError() {
    var _props = this.props,
        standalone = _props.standalone,
        message = _props.message;

    return standalone && message && message.type === 'error';
  };

  FormField.prototype.addSpecificClass = function addSpecificClass() {
    return '';
  };

  /*
   * You should rewrite this method，when you need to format the value as you concern.
   */

  FormField.prototype.formatValue = function formatValue(value) {
    return value;
  };

  FormField.prototype.saveRef = function saveRef(refName) {
    var me = this;
    return function (c) {
      me[refName] = c;
    };
  };

  FormField.prototype.shouldLayoutAsGrid = function shouldLayoutAsGrid() {
    var me = this;
    var gridLayout = me.props.gridLayout || me.props.jsxGridLayout;
    var align = me.props.verticalAlign || me.props.jsxVerticalAlign;
    return !align && Array.isArray(gridLayout) && gridLayout.length > 0;
  };

  FormField.prototype.renderTips = function renderTips() {
    var me = this;
    var mode = me.props.jsxmode || me.props.mode;
    if (mode !== _uxcoreConst2["default"].MODE.EDIT) return null;
    if (me.props.standalone && me.props.message && me.props.message.type === 'tip') {
      return _react2["default"].createElement(
        'li',
        { className: 'kuma-uxform-tips' },
        _react2["default"].createElement(
          'span',
          { ref: me.saveRef('tips'), className: 'kuma-uxform-message-content' },
          me.props.message.message
        )
      );
    }
    if (!!this.props.jsxtips && !me.state.error) {
      return _react2["default"].createElement(
        'li',
        { className: 'kuma-uxform-tips' },
        _react2["default"].createElement(
          'span',
          { className: 'kuma-uxform-message-content', ref: me.saveRef('tips') },
          this.props.jsxtips
        )
      );
    }
    return null;
  };

  /*
   * You should rewrite this method, when you are developing a new type of form field.
   */

  FormField.prototype.renderField = function renderField() {};

  FormField.prototype.renderErrorMsg = function renderErrorMsg() {
    var me = this;
    var mode = me.props.jsxmode || me.props.mode;
    if (mode !== _uxcoreConst2["default"].MODE.EDIT) return null;
    if (this.isMessageError()) {
      return _react2["default"].createElement(
        'li',
        { className: 'kuma-uxform-errormsg' },
        _react2["default"].createElement(
          'span',
          { ref: me.saveRef('errorNode'), className: 'kuma-uxform-message-content' },
          me.props.message.message
        )
      );
    }
    if (me.state.error) {
      return _react2["default"].createElement(
        'li',
        { className: 'kuma-uxform-errormsg' },
        _react2["default"].createElement(
          'span',
          { ref: me.saveRef('errorNode'), className: 'kuma-uxform-message-content' },
          me.state.errMsg
        )
      );
    }
    return null;
  };

  FormField.prototype.renderLabelContent = function renderLabelContent() {
    var me = this;
    var contentProps = {
      className: 'label-content',
      ref: me.saveRef('labelContent')
    };
    if (_react2["default"].isValidElement(me.props.jsxlabel)) {
      contentProps.children = me.props.jsxlabel;
    } else {
      contentProps.dangerouslySetInnerHTML = {
        __html: me.props.jsxlabel
      };
    }
    return _react2["default"].createElement('span', contentProps);
  };

  FormField.prototype.renderLabel = function renderLabel() {
    var me = this;
    var mode = me.props.jsxmode || me.props.mode;
    // jsxVerticalAlign is an internal varible.
    var align = me.props.verticalAlign;
    if (align === undefined) {
      align = me.props.jsxVerticalAlign;
    }
    var style = {
      width: me.props.labelWidth
    };
    if (this.shouldLayoutAsGrid()) {
      style.width = this.getGridLayoutPercent(0);
    }
    if (me.props.jsxshowLabel) {
      return _react2["default"].createElement(
        'label',
        {
          key: 'label',
          ref: this.saveRef('label'),
          className: (0, _classnames3["default"])({
            'kuma-label': true,
            'vertical-align': align,
            'label-match-input-height': me.props.labelMatchInputHeight && mode === _uxcoreConst2["default"].MODE.EDIT
          }),
          style: style
        },
        _react2["default"].createElement(
          'span',
          { className: 'required', ref: me.saveRef('required') },
          me.props.required && mode === _uxcoreConst2["default"].MODE.EDIT ? '* ' : ''
        ),
        this.renderLabelContent()
      );
    }
    return null;
  };

  FormField.prototype.renderContent = function renderContent() {
    var me = this;
    var mode = me.props.jsxmode || me.props.mode;
    var align = me.props.verticalAlign || me.props.jsxVerticalAlign;
    var jsxshowLabel = me.props.jsxshowLabel;

    var fieldStyle = {
      width: this.shouldLayoutAsGrid() ? this.getGridLayoutPercent(1) : undefined
    };
    if (me.props.labelMatchInputHeight && mode === _uxcoreConst2["default"].MODE.EDIT) {
      var tips = me.renderTips();
      var errorMsg = me.renderErrorMsg();
      return [_react2["default"].createElement(
        'div',
        {
          key: 'content',
          style: {
            display: 'table'
          }
        },
        me.renderLabel(),
        _react2["default"].createElement(
          'ul',
          {
            className: (0, _classnames3["default"])({
              'kuma-uxform-field-content': true,
              'view-mode': mode === _uxcoreConst2["default"].MODE.VIEW,
              'edit-mode': mode === _uxcoreConst2["default"].MODE.EDIT,
              'has-error': !!me.state.error || this.isMessageError()
            }),
            style: fieldStyle
          },
          _react2["default"].createElement(
            'li',
            {
              ref: me.saveRef('fieldCore'),
              className: 'kuma-uxform-field-core'
            },
            me.renderField()
          )
        )
      ), tips || errorMsg ? _react2["default"].createElement(
        'div',
        {
          key: 'tip',
          className: 'kuma-uxform-tip-box',
          style: {
            display: 'table',
            width: '100%'
          }
        },
        !align && jsxshowLabel ? _react2["default"].createElement('label', {
          className: (0, _classnames3["default"])({
            'kuma-label': true
          }),
          style: {
            width: this.shouldLayoutAsGrid() ? this.getGridLayoutPercent(0) : undefined
          }
        }) : null,
        _react2["default"].createElement(
          'ul',
          { style: fieldStyle },
          me.renderTips(),
          me.renderErrorMsg()
        )
      ) : null];
    }
    return [me.renderLabel(), _react2["default"].createElement(
      'ul',
      {
        key: 'content',
        className: (0, _classnames3["default"])({
          'kuma-uxform-field-content': true,
          'view-mode': mode === _uxcoreConst2["default"].MODE.VIEW,
          'edit-mode': mode === _uxcoreConst2["default"].MODE.EDIT,
          'has-error': !!me.state.error || this.isMessageError()
        }),
        style: fieldStyle
      },
      _react2["default"].createElement(
        'li',
        {
          key: 'core',
          ref: me.saveRef('fieldCore'),
          className: 'kuma-uxform-field-core'
        },
        me.renderField()
      ),
      me.renderTips(),
      me.renderErrorMsg()
    )];
  };

  FormField.prototype.render = function render() {
    var _classnames,
        _this3 = this;

    var me = this;
    var specificCls = me.addSpecificClass();
    var mode = me.props.jsxmode || me.props.mode;
    var align = me.props.verticalAlign || me.props.jsxVerticalAlign;
    var dataProps = this.getDataProps();
    var style = {};
    if (!me.props.standalone) {
      style.width = me.props.jsxflex / me.props.totalFlex * 100 + '%';
    }
    var size = this.getSize();
    return _react2["default"].createElement(
      'div',
      _extends({
        className: (0, _classnames3["default"])((_classnames = {}, _defineProperty(_classnames, me.props.jsxprefixCls, true), _defineProperty(_classnames, specificCls, !!specificCls), _defineProperty(_classnames, me.props.jsxprefixCls + '-' + size, !!size), _defineProperty(_classnames, me.props.className, !!me.props.className), _defineProperty(_classnames, me.props.jsxprefixCls + '__layout-' + (align ? 'v' : 'h'), true), _defineProperty(_classnames, me.props.jsxprefixCls + '__view', mode === _uxcoreConst2["default"].MODE.VIEW), _defineProperty(_classnames, me.props.jsxprefixCls + '__input-box-' + me.props.inputBoxMaxWidth, ['middle', 'large'].indexOf(me.props.inputBoxMaxWidth) !== -1), _defineProperty(_classnames, me.props.jsxprefixCls + '__all-view', !!me.props.isAllViewMode), _classnames)),
        style: (0, _objectAssign2["default"])({}, style, {
          display: me.props.jsxshow ? 'table' : 'none'
        }),
        ref: function ref(c) {
          _this3.fieldRoot = c;
        }
      }, dataProps),
      me.renderContent()
    );
  };

  return FormField;
}(_react2["default"].Component);

FormField.propTypes = {
  instantValidate: _propTypes2["default"].bool,
  verticalAlign: _propTypes2["default"].bool,
  labelMatchInputHeight: _propTypes2["default"].bool,
  value: _propTypes2["default"].any,
  jsxshow: _propTypes2["default"].bool,
  mode: _propTypes2["default"].string,
  jsxmode: _propTypes2["default"].string,
  jsxshowLabel: _propTypes2["default"].bool,
  jsxprefixCls: _propTypes2["default"].string,
  jsxflex: _propTypes2["default"].number,
  jsxname: _propTypes2["default"].string.isRequired,
  jsxlabel: _propTypes2["default"].string,
  jsxtips: _propTypes2["default"].string,
  jsxrules: _propTypes2["default"].oneOfType([_propTypes2["default"].object, _propTypes2["default"].array, _propTypes2["default"].func]),
  totalFlex: _propTypes2["default"].number,
  standalone: _propTypes2["default"].bool,
  required: _propTypes2["default"].bool,
  attachFormField: _propTypes2["default"].func,
  detachFormField: _propTypes2["default"].func,
  getValues: _propTypes2["default"].func,
  resetValues: _propTypes2["default"].func,
  handleDataChange: _propTypes2["default"].func,
  processValue: _propTypes2["default"].func,
  style: _propTypes2["default"].object,
  labelWidth: _propTypes2["default"].oneOfType([_propTypes2["default"].string, _propTypes2["default"].number]),
  inputBoxMaxWidth: _propTypes2["default"].oneOf(['middle', 'large']),
  gridLayout: _propTypes2["default"].array,
  message: _propTypes2["default"].object
};

FormField.defaultProps = {
  labelMatchInputHeight: false,
  jsxshow: true,
  jsxshowLabel: true,
  jsxprefixCls: 'kuma-uxform-field',
  formPrefixCls: 'kuma-uxform',
  jsxflex: 1,
  jsxname: '',
  jsxlabel: '',
  jsxtips: '',
  standalone: false,
  mode: _uxcoreConst2["default"].MODE.EDIT,
  required: false
};

FormField.displayName = 'FormField';

exports["default"] = FormField;
module.exports = exports['default'];